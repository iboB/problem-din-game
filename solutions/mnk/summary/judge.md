# Играта Дин

## Най-кратко решение

В едно класическо състезание по програмиране тази задача би била зададена с въпроса "С колко минимално хода можем да спечелим играта?" и очакваният изход би бил единствено цяло число.

В този случай най-доброто решение (поне известно на мен) би било това, което повечето участници са избрали:

* Да си представим че възможните състояния на играта са върхове в граф
* Да представим всеки ход като ориентирано ребро в графа
* Да намерим пътя с най-малко ребра от входната позиция до позиция, която съдържа нула в някоя кутия

Това е класическа задача: най-кратък път в ориентиран, непретеглен граф. Решава се чрез търсене в ширина, още известно като breadth-first search, или BFS.

Тъй като графът е и цикличен (например в кутии 1 2 3, можем да завъртим безкраен цикъл с ходове B&rarr;A, A&rarr;B...), е необходима някаква дедупликационна структура, която да ни помогне да не завъртим нашето търсене в ненужни цикли.

Разликите в производителността на различните решения се дължи най-вече на конкретния дедупликационен метод. Това дали е хеш таблица или двоично дърво не изглежда да има особено значение, но ключово за прозизводителността се оказва едно важно наблюдение, което ни помага да елиминираме много голяма част от потенциалните елементи за дедупликация, а именно:

За целите на дедупликацията, можем да разглеждаме всички 6 пермутации на един връх (A;B;C) като идентични. И наистина, броят ходове необходим за решаването на A;B;C е задължително същия като този за B;C;A или всяка друга пермутация.

Тъй като трябваше да има победител и очаквах, че повече от едно решение ще открие минимална бройка ходове въведох следния критерий за оценяване:

> Максималното допустимо време за работа на програмата е 5 секунди. Всички решения, които надхвърлят това време или дадат грешен отговор (поредица от ходове, които не водят до изпразването на някоя от кутиите или `NOT POSSIBLE` при възможно решение), получават по 0 точки.
> За всеки тест верните решения се сортират по брой ходове в получената от тях поредица. Решенията с най-кратък брой получават по 10 точки, а останалите по 1. Решенията с най-кратък брой ходове се сортират по бързодействие и първите три от тях получават по 3, 2 и 1 допълнителни точки.

Ранглистата по този критерий можете да намерите [тук](shortest.md).

## Най-бързо решение

За мен тази задача е интересна и с друго. Освен "класическия" състезателен подход на най-краткото решение, тя позволява и подход, който работи много бързо, не използва почти никакви ресурси, но не произвежда минималното количество ходове.

Когато поставих задачата, нарочно не добавих критерии за оценяване. Исках да видя дали някой ще избере такъв подход, без да разочаровам класическите състезатели като наложа точно него.

В крайна сметка имаше само едно такова решение, но то илюстрира какво искам да кажа: нула алокации, единствена функция за решение, която за всяка тройка A;B;C произвежда следващия ход и... това е.

Предварително подходтвих и алтернативен крирерий за оценяване:

> За всеки тест верните решения се сортират по бързодействие, независимо от броя ходове. Първите 9 от тях получават съответно от 10 до 2 точки, а всички останали по 1.

Очаквано единственото решение предадено с тази цел, печели. Ранглистата може да видите [тук](fastest.md).

За това как работи подобно решение може да се опитате да докажете, че изходът `NOT POSSIBLE` е уловка, и всъщност играта може да бъде спечелена за всяка тройка естествени числа. По пътя на това доказателство, ще стигнете и до алгоритъм за решение, което има повече ходове от минималното възможно, но работи в порядъци по-бързо. Доказателството не единствено и съответно съществува няколко алгоритъма от вида `produceNextMove(a,b,c)`.

## Победител

Тъй като повечето участници избраха "класическото" решение, следва да уважим това мнозинство и първо място печели победителят от най-кратките решения: [s210702_1740](../s210702_1740.cpp)

Все пак специална втора награта за елегантност и ефективност, които не противоречат на условието на задачата, печели и единственото решение, което се целеше във втория критерий: [s210630_1608](../s210630_1608.cpp)
